#!/bin/bash



#### Description: Wrapper script to call genomic variants from ENCODE DCC hic-pipeline.
#### Usage: bash ./run-gatk-after-juicer2.sh [options] <path_to_merged_dedupped_bam_1>[ ... <path_to_merged_dedup_bam_N>].
#### Input: merged_dedup.bam file (or list of merged_dedup.bam files) from Juicer2.
#### Output: snp.out.vcf and indel.out.vcf
#### Dependencies: Java, GATK (picard), samtools, GNU Parallel.
#### Written by: Olga Dudchenko, with contributions from Huiya Gu and Gamze Gursoy. Version: 09/05/2021 [updated from version date 07/25/2021, 08/20/2020, 8/11/2020].

# cluster-specific
# spack load samtools@1.13 arch=$(spack arch)

echo "*****************************************************" >&1
echo "cmd log: "$0" "$* >&1
echo "*****************************************************" >&1


USAGE="
*****************************************************
Call SNPs from ENCODE DCC Hi-C pipeline (Juicer2). Original version: 7/25/2021. Current version: 09/05/2021.

USAGE: ./run-gatk-after-juicer2.sh [options] <path_to_merged_dedupped_bam_1>[ ... <path_to_merged_dedup_bam_N>

DESCRIPTION:
This is a wrapper script to use GATK4 to call SNPs from Hi-C alignment data as generated by the ENCODE DCC Hi-C pipeline (aka Juicer2).

ARGUMENTS:
path_to_aligned_dedupped_bam
						Path to bam file containing deduplicated alignments of Hi-C reads in bam format (output by Juicer2).  Multiple bam files can be passed as arguments.

OPTIONS:
-h|--help
						Shows this help.
						
-r|--reference <path_to_fasta>
						Pointer to reference that was used to process the Hi-C data. Required.

-c|--coverage [approx_clean_coverage_in_X_of_genomes]
						Target coverage in terms of \"clean\" alignment data. If bam coverage exceeds the target the reads will be subsampled to perform SNP calling. Set to 0 to disable. Default: 30.

-f|--fraction [fraction_of_input_bam_to_be_used]
						Fraction of alignment data to be used for subsampling. Overrides the targe coverage parameter. Deafult: 1.0.
-s|--sample [sample_name]
						Overwrite sample information.

GATK CONTROL:

--gatk-bundle <path_to_GATK_bundle>
						Shortcut to use GATK resources for base recalibration and variant recalibration when processing human data. For non-human data pass known vcf files if available explicitely with --known-sites-for-base-recalibration, --known-sites-for-snp-recalibration and --known-sites-for-indel-recalibration options.

--known-sites-for-base-recalibration <path_to_vcf_file_w_known_polymorphisms>
						Use set of variants from a given vcf file for base recalibration. Multiple vcf files can be passed with multiple option invocations.

--known-sites-for-snp-recalibration <path_to_vcf_file_w_known_polymorphisms>
						Use set of variants from a given vcf file for snp recalibration. Multiple vcf files can be passed with multiple option invocations. All databases are assigned with prior=10.0.

--known-sites-for-indel-recalibration <path_to_vcf_file_w_known_polymorphisms>
						Use set of variants from a given vcf file for indel recalibration. Multiple vcf files can be passed with multiple option invocations. All databases are assignd with prior=2.0.

-q|--mapq [min_mapping_quality]
						Ignore reads with mapping quality less than [min_mapping_quality]. Overrides the default GATK MappingQualityReadFilter. Default: 10. 

--min-base-quality-score [min_base_quality_score]
						Minimum base quality required to consider a base for variant calling. Passed on to GATK. Default: 10.

HIC-SPECIFIC CONTROL:

--restriction-site-file <path_to_restriction_site_file>
						Pass the restriction site file when processign a Hi-C experiment generated with a known restriction enzyme to exclude regions immediately around the cut site from SNP analysis. Default: ignore option.
						
--exclusion-interval [num_in_bp]
 						Use this option to tweak the padding aroun the restriction site position. Default: 5bp.						
								
WORKFLOW CONTROL:

-t|--threads [num]
        				Indicate how many threads to use. Default: half of available cores as calculated by parallel --number-of-cores.
						
--from-stage [pipeline_stage]
						Fast-forward to a particular stage of the pipeline. The pipeline_stage argument can be \"prep\", \"sort\", \"recalibrate_bases\", \"genotype\", \"recalibrate_variants\", \"cleanup\". 

--to-stage [pipeline_stage]
						Exit after a particular stage of the pipeline. The argument can be \"prep\", \"sort\", \"recalibrate_bases\", \"genotype\", \"recalibrate_variants\", \"cleanup\".
									
*****************************************************
"


## HANDLE DEPENDENCIES
	
type samtools >/dev/null 2>&1 || { echo >&2 ":( Samtools are not available, please install/add to path. Exiting!"; exit 1; }
ver=`samtools --version | awk 'NR==1{print \$NF}'`
[[ $(echo "$ver < 1.13" |bc -l) -eq 1 ]] && { echo >&2 ":( Outdated version of samtools is installed. Please install/add to path v 1.13 or later. Exiting!"; exit 1; }

type java >/dev/null 2>&1 || { echo >&2 ":( Java is not available, please install/add to path Java to run GATK. Exiting!"; exit 1; }

type gatk >/dev/null 2>&1 || { echo >&2 ":( GATK is not available, please install/add to path as gatk to run SNP calling. Exiting!"; exit 1; }
[[ $(gatk --version | awk '$0~/GATK/{gsub(/\./,""); ver=substr($NF,2)}END{len=length(ver); test=41; for(i=1;i<=len-2;i++){test=test"0"}; if(test>ver){print "fail"}}') == "fail" ]] && { echo >&2 ":( Outdated version of GATK is installed. Please install/add to path v 4.1 or later. Exiting!"; exit 1; }

type parallel >/dev/null 2>&1 || { echo >&2 ":( GNU Parallel support is set to true (default) but GNU Parallel is not in the path. Please install GNU Parallel or set -p option to false. Exiting!"; exit 1; }
	
## HANDLE OPTIONS

#subsampling
target_coverage=30;

#for gatk
mapq=10;
mbq=10;

#hic specific
exclusion_interval=3;

#multithreading
threads=`parallel --number-of-cores`
threads=$((threads/2))
# adjust for mem usage
tmp=`awk '/MemTotal/ {threads=int($2/1024/1024/2/6-1)}END{print threads+0}' /proc/meminfo 2>/dev/null`
tmp=$((tmp+0))
([ $tmp -gt 0 ] && [ $tmp -lt $threads ]) && threads=$tmp

#staging
first_stage="prep"
last_stage="cleanup"
declare -A stage
stage[prep]=1
stage[sort]=2
stage[recalibrate_bases]=3
stage[genotype]=4
stage[recalibrate_variants]=5
stage[cleanup]=6

while :; do
	case $1 in
		-h|--help)
			echo "$USAGE" >&1
			exit 0
        ;;
        -r|--reference) OPTARG=$2
        	if [ -f ${OPTARG} ]; then
        		echo " -r|--reference flag was triggered, assuming $OPTARG is the fasta used to align the data." >&1
        		reference=$OPTARG	# should be getting this from the metadata.json file
        	else
        		echo " :( Reference fasta not found in expected location, exiting!" >&2
        		exit 1
        	fi
        	shift
        ;;
		-c|--coverage) OPTARG=$2 
			re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
					[[ $OPTARG -eq 0 ]] && echo " -c|--coverage flag was triggered with 0 value. Will not subsample input data." || echo " -c|--coverage flag was triggered. Will subsample input bam if necessary to roughly correspond to ${OPTARG}X of genome of aligned data for variant calling." >&1
					target_coverage=$OPTARG
			else
					echo " :( Wrong syntax for subsampling parameter value. Exiting!" >&2
					exit 1
			fi        	
        	shift
		;;
		-f|--fraction) OPTARG=$2
			fl='^0.[0-9]+$'
			if [[ $OPTARG =~ $fl ]]; then
					echo " -f|--fraction flag was triggered. Will subsample input bam by $OPTARG fraction." >&1
					fraction=$OPTARG
			else
					echo " :( Wrong syntax for fraction parameter value. Exiting!" >&2
					exit 1
			fi        	
        	shift		
		;;
		-s|--sample) OPTARG=$2
			echo " -s|--sample frag was triggered. Will overwrite all SM tags in bam(s)." >&1
			sample_name=$OPTARG
			shift;
		;;
        --gatk-bundle) OPTARG=$2
        	if [ -d $OPTARG ]; then
        		echo " --gatk-bundle flag was triggered. Will attempt to use files in the GATK bundle folder for base and variant recalibration. Please double-check that you are using the corrent GATK bundle for your genome, i.e. it is the same version of the genome (hg19/hg38) and the naming convention for the chromosomes is the same!"
				
				#Hapmap
				vcfHapmap=$(find $OPTARG -type f -name "*hapmap*.vcf" -o -name "*hapmap*.vcf.gz" | xargs ls -lht | sort -k 5 -nr | sed 's/ \+/\t/g' | cut -f 9 | awk 'NR==1')
				if [ ! -z ${vcfHapmap} ]; then
					echo "  ... found $vcfHapmap file, will use as Hapmap known variant database for base recalibration and/or variant recalibration." >&1
					knownSitesArg=${knownSitesArg}" --known-sites $vcfHapmap"
					snpRecalibrationArg=${snpRecalibrationArg}" --resource:hapmap,known=false,training=true,truth=true,prior=15.0 $vcfHapmap"
				fi
				
				#Omni
				vcfOmni=$(find $OPTARG -type f -name "*omni*.vcf" -o -name "*omni*.vcf.gz" | xargs ls -lht | sort -k 5 -nr | sed 's/ \+/\t/g' | cut -f 9 | awk 'NR==1')
				if [ ! -z ${vcfOmni} ]; then
					echo "  ... found $vcfOmni file, will use as Omni known variant database for base recalibration and/or variant recalibration." >&1
					knownSitesArg=${knownSitesArg}" --known-sites $vcfOmni"
					snpRecalibrationArg=${snpRecalibrationArg}" --resource:omni,known=false,training=true,truth=true,prior=12.0 $vcfOmni"
				fi
				
				#Mills
				vcfMills=$(find $OPTARG -type f -name "*Mills*.vcf" -o -name "*Mills*.vcf.gz" | xargs ls -lht | sort -k 5 -nr | sed 's/ \+/\t/g' | cut -f 9 | awk 'NR==1')
				if [ ! -z ${vcfMills} ]; then
					echo "  ... found $vcfMills file, will use as Mills known variant database for base recalibration and/or variant recalibration." >&1
					knownSitesArg=${knownSitesArg}" --known-sites $vcfMills"
					indelRecalibrationArg=${indelRecalibrationArg}" --resource:mills,known=false,training=true,truth=true,prior=12.0 $vcfMills"
				fi
				
				#Dbsnp
				vcfDbsnp=$(find $OPTARG -type f -name "*dbsnp*.vcf" -o -name "*dbsnp*.vcf.gz" | xargs ls -lht | sort -k 5 -nr | sed 's/ \+/\t/g' | cut -f 9 | awk 'NR==1')
				if [ ! -z ${vcfDbsnp} ]; then
					echo "  ... found $vcfDbsnp file, will use as Dbsnp known variant database for base recalibration and/or variant recalibration." >&1
					knownSitesArg=${knownSitesArg}" --known-sites $vcfDbsnp"
					snpRecalibrationArg=${snpRecalibrationArg}" --resource:dbsnp,known=true,training=false,truth=false,prior=7.0 $vcfDbsnp"
					indelRecalibrationArg=${indelRecalibrationArg}" --resource:dbsnp,known=true,training=false,truth=false,prior=2.0 $vcfDbsnp"
				fi
				
        	else
        		echo " :( Cannot find bundle folder, exiting!" >&2
        		exit 1
        	fi
        	shift
        ;;
        --known-sites-for-base-recalibration) OPTARG=$2
        	if [ -f ${OPTARG} ]; then
				echo " --known-sites-for-base-recalibration flag was triggered with known polymorphic sites listed in $OPTARG. Will use for GATK Base Recalibration module." >&1
				knownSitesArg=${knownSitesArg}" --known-sites $OPTARG"
			else
				echo " --known-sites-for-base-recalibration flag was triggered but vcf file with known polymorphic sites is not found in expected location. Exiting! " >&2
				exit 1
			fi
			shift
        ;;
        --known-sites-for-snp-recalibration) OPTARG=$2
			if [ -f ${OPTARG} ]; then
				echo " --known-sites-for-snp-recalibration flag was triggered with known polymorphic sites listed in $OPTARG. Will use for GATK Base Recalibration module." >&1
				snpRecalibrationArg=${snpRecalibrationArg}" --resource:other,known=true,training=false,truth=false,prior=10.0 $OPTARG"
			else
				echo " --known-sites-for-snp-recalibration flag was triggered but vcf file with known polymorphic sites is not found in expected location. Exiting! " >&2
				exit 1
			fi
        	shift
        ;;
        --known-sites-for-indel-recalibration) OPTARG=$2
                if [ -f ${OPTARG} ]; then
					echo " --known-sites-for-indel-recalibration flag was triggered with known polymorphic sites listed in $OPTARG. Will use for GATK Base Recalibration module." >&1
					indelRecalibrationArg=${indelRecalibrationArg}" --resource:other,known=true,training=false,truth=false,prior=2.0 $OPTARG"
			else
				echo " --known-sites-for-indel-recalibration flag was triggered but vcf file with known polymorphic sites is not found in expected location. Exiting! " >&2
				exit 1
			fi
        	shift
        ;;

# GATK related:
		-q|--mapq) OPTARG=$2
			re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
					echo " -q|--mapq flag was triggered, will skip all alignment with mapping quality smaller than $OPTARG." >&1
					mapq=$OPTARG
			else
					echo " :( Wrong syntax for mapping quality parameter value. Exiting!" >&2
					exit 1
			fi        	
        	shift
        ;;
		--min-base-quality-score) OPTARG=$2
			re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
					echo " --min-base-quality-score flag was triggered, will pass \"-mbq $OPTARG\" as parameter to GATK." >&1
					mbq=$OPTARG
			else
					echo " :( Wrong syntax for min base quality score parameter value. Exiting!" >&2
					exit 1
			fi        	
        	shift
        ;;

# Optional RE filtration:
		--restriction-site-file) OPTARG=$2
        	if [ -f ${OPTARG} ]; then
				echo " --restriction-site-file flag was triggered with known restriction sites listed in $OPTARG. Will use for GATK Base Recalibration & HaplotypeCaller modules. WARINING: Deprecated." >&1
				restriction_site_file=$OPTARG
			else
				echo " --restriction-site-file flag was triggered but file with known polymorphic sites is not found in expected location. Exiting! " >&2
				exit 1
			fi
			shift
        ;;
        --exclusion-interval) OPTARG=$2
        	re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
					echo " --exclusion-interval flag was triggered, will exclude +/-${OPTARG} bases around restriction sites." >&1
					exclusion_interval=$OPTARG
			else
					echo " :( Wrong syntax for exclusion interval parameter value. Exiting!" >&2
					exit 1
			fi
			shift
        ;;
        
# WORKFLOW:
        -t|--threads) OPTARG=$2
        	re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
					echo " -t|--threads flag was triggered, will try to parallelize across $OPTARG threads." >&1
					threads=$OPTARG
			else
					echo " :( Wrong syntax for thread count parameter value. Exiting!" >&2
					exit 1
			fi        	
        	shift
        ;;
        --from-stage) OPTARG=$2
			if [ "$OPTARG" == "prep" ] || [ "$OPTARG" == "sort" ] || [ "$OPTARG" == "recalibrate_bases" ] || [ "$OPTARG" == "genotype" ] || [ "$OPTARG" == "recalibrate_variants" ] || [ "$OPTARG" == "cleanup" ]; then
        		echo " --from-stage flag was triggered. Will fast-forward to $OPTARG." >&1
        		first_stage=$OPTARG
			else
				echo " :( Whong syntax for pipeline stage. Please use prep/sort/recalibrate_bases/genotype/recalibrate_variants/cleanup. Exiting!" >&2
				exit 1
			fi
			shift
        ;;
		--to-stage) OPTARG=$2
			if [ "$OPTARG" == "prep" ] || [ "$OPTARG" == "sort" ] || [ "$OPTARG" == "recalibrate_bases" ] || [ "$OPTARG" == "genotype" ] || [ "$OPTARG" == "recalibrate_variants" ] || [ "$OPTARG" == "cleanup" ]; then
				echo " --to-stage flag was triggered. Will exit after $OPTARG." >&1
				last_stage=$OPTARG
			else
				echo " :( Whong syntax for pipeline stage. Please use prep/sort/recalibrate_bases/genotype/recalibrate_variants/cleanup. Exiting!" >&2
				exit 1			
			fi
			shift
		;;
		--) # End of all options
			shift
			break
		;;
		-?*)
			echo " :| WARNING: Unknown option. Ignoring: ${1}" >&2
		;;
		*) # Default case: If no more options then break out of the loop.
			break
	esac
	shift
done

[ -z $reference ] && { echo ":( Cannot find fasta in expected location. Exiting!" && exit 1; }

if [ ! -z "${restriction_site_file}" ]; then
	[ -f restriction_site.bed ] && echo "...Found a restriction_site.bed file in the folder. Will used it to exclude relevant intervals from variant calling." || { echo "...Converting restriction site file to bed assuming the exclusion interval to be +/-${exclusion_interval}bp." >&1 && awk -v interval=${exclusion_interval} 'BEGIN{OFS="\t"}{chr=$1; for(i=2; i<=NF; i++){print chr, ($i-interval), ($i+interval)}}' ${restriction_site_file} > restriction_site.bed; }
	excludeIntervalsArg="--exclude-intervals restriction_site.bed"
else
	excludeIntervalsArg=""
fi

if [[ "${stage[$first_stage]}" -gt "${stage[$last_stage]}" ]]; then
	echo >&2 ":( Please make sure that the first stage requested is in fact an earlier stage of the pipeline to the one requested as last. Exiting!"
	exit 1
fi


## HANDLE ARGUMENTS

bam=`echo "${@:1}"`
echo "...Bam file(s) to be processed: $bam" >&1
#TODO: check file extensions and readability
#[[ -f ${bam} ]] || { echo >&2 ":( Can't find the dedupped bam file. Exiting!"; exit 1; }


## I. PREP FASTA FOR PARALLEL PROCESSING

if [ "$first_stage" == "prep" ]; then

	echo "...Analyzing reference data." >&1

	[ "${reference: -3}" == ".gz" ] && { echo >&2 ":( Please unzip your reference. Exiting!"; exit 1; }
	[ -f `basename $reference` ] || ln -sf $reference .
	
	echo "	...Looking for $reference.fai."
	[ -f $reference".fai" ] && ln -sf $reference".fai" . || samtools faidx $reference
	
	echo "	...Looking for ${reference%.*}.dict."
	refbasename=`basename $reference`	
	refbasename=`basename $refbasename .fa`
	refbasename=`basename $refbasename .fna`
	refbasename=`basename $refbasename .fasta`
	[ -f ${reference%.*}".dict" ] && ln -sf ${reference%.*}".dict" . || gatk CreateSequenceDictionary -R $reference -O "$refbasename.dict"
	
	echo "	...Looking for "${reference%.*}".interval_list."
	[ -f ${reference%.*}".interval_list" ] && ln -sf ${reference%.*}".interval_list" . || gatk ScatterIntervalsByNs -R $reference -OT ACGT -N 500 -O "$refbasename.interval_list"

	reference=`basename $reference`

	totlen=`awk -F '\t' '$0!~/^@/{c+=$3-$2}END{print c}' $refbasename.interval_list`
	threads=`awk -v len=$((totlen/threads + 1)) 'BEGIN{FS="\t"; OFS="\t"; counter++}$0~/^@/{next}{if(c>len){counter++; c=0}; print $0>"split."counter".bed"; c+=$3-$2}END{print counter}' $refbasename.interval_list`

	echo "...Will use $threads threads." >&1

	[ "$last_stage" == "prep" ] && { echo "Done with the requested workflow. Exiting after prep!"; exit; }
	first_stage="sort"

else
	reference=`basename $reference`
	if [ ! -f $reference ] || [ ! -f $reference".fai" ] || [ ! -f ${reference%.*}".dict" ] || [ ! -f ${reference%.*}".interval_list" ]; then
		echo ":( Files from previous stages of the pipeline appear to be missing. Exiting!"
		exit 1
	fi
	threads=`find . -maxdepth 1 -name "split.*.bed" | wc -l`
	[ $threads -eq 0 ] && { echo >&2 ":( Files from previous stages of the pipeline appear to be missing. Exiting!"; exit 1; } || echo  >&1 "...Will use $threads threads."
fi

## II. SUBSAMPLE, ASSIGN READ GROUP [formally] AND SORT BAM. DEDUP IS ALREADY DONE.

if [ "$first_stage" == "sort" ]; then
	
	echo "...Sorting bam." >&1

	if [[ -z ${fraction} ]]; then
		fraction="1.0"
		if [[ ${target_coverage} -ne 0 ]]; then
		{
			echo "...Estimating fraction of data to be used for SNP calling:"
			
			# don't see any reliable way to do this except look though the file
			#samtools cat -@ $((threads * 2)) 
			samtools cat $bam | samtools view -u -@ $((threads * 2)) -F 0x400 -q $mapq -s 0.001 - \
				| samtools sort -@ $threads -m 6G -o test.sorted.bam

			# samtools cat $bam | samtools view -u -d "rt:0" -d "rt:1" -d "rt:2" -d "rt:3" -d "rt:4" -d "rt:5" -d "rt:7" -@ $((threads * 2)) -F 0x400 -q $mapq -s 0.001 - | samtools sort -@ $threads -m 6G -o test.sorted.bam

			[ $? -eq 0 ] || { echo ":( Failed at extimating the necessary read fraction. See err stream for more info. Exiting!" | tee -a /dev/stderr && exit 1; }

			samtools index -@ $threads test.sorted.bam
			[ $? -eq 0 ] || { echo ":( Failed at read indexing. See err stream for more info. Exiting!" | tee -a /dev/stderr && exit 1; }		

			coverage=$(samtools depth test.sorted.bam -b split.1.bed | awk 'FILENAME==ARGV[1]{l+=$3-$2;next}{c+=$3}END{print int(1000*c/l)}' split.1.bed -)
			
			[[ $coverage -eq 0 ]] || fraction=`echo "scale=2; ${target_coverage}/${coverage}" | bc -l`
			
			([[ $coverage -eq 0 ]] || [[ `echo "$fraction > 1" | bc` -eq 1 ]]) && (echo "Estimated \"clean\" coverage (${coverage}X) is lower than requested coverage (${target_coverage}X). Will use all available data." | tee -a /dev/stderr && fraction="1.0")
			echo "...Fraction to be used for SNP calling: "$fraction"."

			# rm test.sorted.bam test.sorted.bam.bai
		}
		fi
	fi 

	# make header for the merged file pipe
	echo "...${sample_name} is sample_name" >&1
	[ -z ${sample_name} ] && parallel --will-cite "samtools view -H {} > {}_header.sam" ::: $bam || parallel --will-cite "samtools view -H {} | sed \"/^@RG/s/SM:[^\t]*/SM:"${sample_name}"/g\" > {}_header.sam" ::: $bam
	
	header_list=`parallel --will-cite "printf %s' ' {}_header.sam" ::: $bam`
	samtools merge --no-PG -f mega_header.bam ${header_list}
	rm ${header_list}

	# sort and index	 -@ $((threads * 2)) 
	samtools cat -h mega_header.bam $bam | samtools view -u -@ $((threads * 2)) -F 0x400 -q $mapq -s $fraction - |  samtools sort -@ $threads -m 16G -o reads.sorted.bam

	# samtools cat -h mega_header.bam $bam | samtools view -u -d "rt:0" -d "rt:1" -d "rt:2" -d "rt:3" -d "rt:4" -d "rt:5" -d "rt:7" -@ $((threads * 2)) -F 0x400 -q $mapq -s $fraction - |  samtools sort -@ $threads -m 6G -o reads.sorted.bam
	[ $? -eq 0 ] || { echo ":( Failed at read sorting. See err stream for more info. Exiting!" | tee -a /dev/stderr && exit 1; }

	samtools index -@ $threads reads.sorted.bam	
	[ $? -eq 0 ] || { echo ":( Failed at read indexing. See err stream for more info. Exiting!" | tee -a /dev/stderr && exit 1; }		
	# e.g. will fail with chr longer than ~500Mb. Use samtools index -c -m 14 reads.sorted.bam

	[ "$last_stage" == "sort" ] && { echo ":) Done with the requested workflow. Exiting after sort!"; exit; }
	first_stage="recalibrate_bases"

fi

## III. PERFORM BASE RECALIBRATION IF REQUESTED
# gatk BaseRecalibator &  gatk ApplyBQSR
if [ "$first_stage" == "recalibrate_bases" ]; then

	([ -f reads.sorted.bam ] && [ -f reads.sorted.bam.bai ]) || { echo >&2 ":( Files from previous stages of the pipeline appear to be missing. Exiting!"; exit 1; }

	# check platform information and recalibrate only if Illumina

	test=$(samtools view -H reads.sorted.bam | awk '$0~/^@RG/{match($0, /(PL:)[^\t]*/, arr); PL[substr(arr[0],4)]=1}END{if(length(PL)!=1||PL["ILM"]!=1){print 1}else{print 0}}')

	[[ $test -eq 1 ]] && { echo ":| WARNING: Platform is not Illumina, is unknown or mixed. Will skip base recalibration if requested." | tee -a /dev/stderr; }

 	if [[ ! -z ${knownSitesArg} ]] && [[ $test -ne 1 ]]; then

		echo "...Recalibrating bases in bam." >&1
						
		seq 1 $threads | parallel --will-cite --joblog temp.log \
			"gatk --java-options \"-Xmx10G -XX:+UseParallelGC -XX:ParallelGCThreads=4\" \
			BaseRecalibrator -L split.{}.bed \
			-I reads.sorted.bam \
			-R $reference \
			${knownSitesArg} ${excludeIntervalsArg} -O recal_data_{}.table"
		exitval=`awk 'NR>1{if($7!=0){c=1; exit}}END{print c+0}' temp.log`
		
		[ $exitval -eq 0 ] || { echo ":( Pipeline failed at gatk BaseRecalibator. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }
		
		seq 1 $threads | parallel --will-cite --joblog temp.log \
			"gatk ApplyBQSR --java-options \"-Xmx4G -Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=4\" \
			-R $reference \
			-I reads.sorted.bam --bqsr-recal-file recal_data_{}.table \
			-L split.{}.bed \
			--static-quantized-quals 10 \
			--static-quantized-quals 20 \
			--static-quantized-quals 30 \
			-O reads.prepped_{}.bam"
		exitval=`awk 'NR>1{if($7!=0){c=1; exit}}END{print c+0}' temp.log`
		
		[ $exitval -eq 0 ] || { echo ":( Pipeline failed at gatk ApplyBQSR. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }

		seq 1 $threads | parallel --will-cite "rm recal_data_{}.table"
		rm temp.log
		
	else
		echo "...Proceeding without recalibrating bases."
		# seq 1 $threads | parallel --will-cite "samtools view -L split.{}.bed -o reads.prepped_{}.bam reads.sorted.bam && samtools index reads.prepped_{}.bam"
		seq 1 $threads | parallel --will-cite "ln -sf reads.sorted.bam reads.prepped_{}.bam"
		seq 1 $threads | parallel --will-cite "ln -sf reads.sorted.bam.bai reads.prepped_{}.bai"
	fi

	[ "$last_stage" == "recalibrate_bases" ] && { echo ":) Done with the requested workflow. Exiting after base recalibration!"; exit; }
	first_stage="genotype"

fi

##	IV. RUNNING HAPLOTYPE CALLER
# GATK HaplotypeCaller,GATK GatherVcfs
if [ "$first_stage" == "genotype" ]; then

	tmp_count=`find . -maxdepth 1 -name "reads.prepped_*.bam" | wc -l`
	tmp_count2=`find . -maxdepth 1 -name "reads.prepped_*.bai" | wc -l`

	([ $tmp_count -eq $threads ] && [ $tmp_count2 -eq $threads ]) || { echo >&2 ":( Files from previous stages of the pipeline appear to be missing. Exiting!"; exit 1; }

	echo "...Calling haplotypes." >&1
	echo "...$excludeIntervalsArg." >&1
	seq 1 $threads | parallel --will-cite --joblog temp.log \
		"gatk --java-options \"-Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=1\" \
		HaplotypeCaller \
		-R $reference -I reads.prepped_{}.bam \
		-O raw_{}.vcf -L split.{}.bed \
		--dont-use-soft-clipped-bases true -pairHMM FASTEST_AVAILABLE \
		--native-pair-hmm-threads 8 \
		$excludeIntervalsArg \
		--dbsnp $vcfDbsnp \
		--disable-read-filter MappingQualityReadFilter --smith-waterman FASTEST_AVAILABLE --min-base-quality-score $mbq"
	exitval=`awk 'NR>1{if($7!=0){c=1; exit}}END{print c+0}' temp.log`

	[ $exitval -eq 0 ] || { echo ":( Pipeline failed at GATK HaplotypeCaller. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }

	# cleanup
	seq 1 $threads | parallel --will-cite "rm reads.prepped_{}.bam reads.prepped_{}.bai"

	arg=$(seq 1 $threads | parallel --will-cite -k "printf -- \" -I %s\" raw_{}.vcf")
	gatk --java-options "-Xmx4G" GatherVcfs -R $reference $arg -O raw.vcf
	[ $? -eq 0 ] || { echo ":( Failed at GATK GatherVcfs. See err stream for more info. Exiting!" | tee -a /dev/stderr && exit 1; }

	# cleanup
	seq 1 $threads | parallel --will-cite "rm raw_{}.vcf raw_{}.vcf.idx"
	rm temp.log

	[ "$last_stage" == "genotype" ] && { echo ":) Done with the requested workflow. Exiting after genotyping!"; exit; }
	first_stage="recalibrate_variants"

fi

##	V. PERFORMING VARIANT RECALIBRATION OR VARIANT FILTERING
# GATK VariantRecalibrator, GATK ApplyVQSR |  GATK SelectVariants, GATK VariantFiltration
if [ "$first_stage" == "recalibrate_variants" ]; then

	# 生成 out.vcf, snp.out.vcf 和 indel.out.vcf

	([ -f raw.vcf ] && [ -f raw.vcf.idx ]) || { echo >&2 ":( Files from previous stages of the pipeline appear to be missing. Exiting!"; exit 1; }

	# TODO: More work on hard filtration

	if [[ ! -z ${snpRecalibrationArg} ]]; then
		echo "...Performing SNP recalibration." >&1
		echo -e "\nV.1 $snpRecalibrationArg\n" >&1
		gatk --java-options "-Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=40" VariantRecalibrator \
			-V raw.vcf -O out.recal -mode SNP --tranches-file out.tranches \
			-tranche 100.0 -tranche 99.9 -tranche 99.0 -tranche 90.0 -an QD -an FS \
			-an MQRankSum -an ReadPosRankSum -an SOR -an MQ --max-gaussians 6 ${snpRecalibrationArg}

		[ $? -eq 0 ] || { echo ":( Failed at SNP recalibration. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }
		
		echo -e "\nV.2 ... ApplyVQSR raw.vcf....\n" >&1
		gatk --java-options "-Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=20" ApplyVQSR \
			-V raw.vcf -O recalibrated_snps_raw_indels.vcf \
			--recal-file out.recal --tranches-file out.tranches \
			-truth-sensitivity-filter-level 99.5 \
			--create-output-variant-index true -mode SNP

		[ $? -eq 0 ] || { echo ":( Failed at SNP recalibration. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }

		vcf=recalibrated_snps_raw_indels.vcf
		
	else
		echo "...No known SNPs are provided for variant recalibration. Opting out for hard-filtering."
		gatk SelectVariants -V raw.vcf -select-type SNP -O snp.raw.vcf
		gatk VariantFiltration -R $reference -V snp.raw.vcf --filter "QD < 2.0" \
			--filter-name "QD2" --filter "FS > 60.0" --filter-name "FS60" --filter "MQ < 10.0" \
			--filter-name "MQ10" --filter "ReadPosRankSum < -8.0" --filter-name "ReadPosRandSum-8" \
			--filter "SOR > 3.0" --filter-name "SOR3" --filter "QUAL < 30.0" --filter-name "QUAL30" -O snp.out.vcf
		rm snp.raw.vcf snp.raw.vcf.idx
	#	 --filter "MQRankSum < -12.5" --filter-name "MQRankSum-12.5"

		vcf=raw.vcf
	
	fi

	if [[ ! -z $indelRecalibrationArg ]]; then
		echo "...Performing InDel recalibration." >&1
		echo -e "\nV.3 $indelRecalibrationArg\n" >&1
		gatk --java-options "-Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=40" VariantRecalibrator \
			-V ${vcf} -O out.recal -mode INDEL --tranches-file out.tranches \
			-tranche 100.0 -tranche 99.9 -tranche 99.0 -tranche 90.0 -an QD -an FS \
			-an MQRankSum -an ReadPosRankSum -an SOR --max-gaussians 4 ${indelRecalibrationArg}

		# consider playing with recalibration annotation list:
		#--vqsr-annotation SNP,DP,QD,FS,ReadPosRankSum,MQRankSum,MQ
		#--vqsr-annotation INDEL,DP,QD,FS,ReadPosRankSum,MQRankSum

		[ $? -eq 0 ] || { echo ":( Failed at InDel recalibration. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }
		
		gatk --java-options "-Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=20" ApplyVQSR \
			-V ${vcf} -O out.vcf --recal-file out.recal --tranches-file out.tranches \
			-truth-sensitivity-filter-level 99.0 -mode INDEL --create-output-variant-index

		# consider playing with recalibration filter level:
		#--vqsr-filter-level INDEL,90.0

		[ $? -eq 0 ] || { echo ":( Failed at InDel recalibration. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }
	
		gatk SelectVariants -V out.vcf -select-type INDEL -O indel.out.vcf

		[ $? -eq 0 ] || { echo ":( Failed at SelectVariants after indel recalibration. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }

		vcf=out.vcf

	else
		echo "...No known InDels are provided for indel recalibration. Opting out for hard-filtering."
		gatk SelectVariants -V ${vcf} -select-type INDEL -O indel.raw.vcf
		gatk VariantFiltration -R $reference -V indel.raw.vcf --filter "QD < 2.0" \
			--filter-name "QD2" --filter "FS > 200.0" --filter-name "FS200" --filter "ReadPosRankSum < -20.0" \
			--filter-name "ReadPosRandSum-20" --filter "QUAL < 30.0" --filter-name "QUAL30" -O indel.out.vcf
		rm indel.raw.vcf indel.raw.vcf.idx
	fi

	# harmonize output
	if [[ ! -z ${snpRecalibrationArg} ]]; then
		gatk SelectVariants -V ${vcf} -select-type SNP -O snp.out.vcf
	fi

	[ -f out.tranches ] && rm out.tranches
	[ -f out.recal ] && rm out.recal*
	[ -f recalibrated_snps_raw_indels.vcf ] && rm recalibrated_snps_raw_indels.vcf*

	[ "$last_stage" == "recalibrate_variants" ] && { echo ":) Done with the requested workflow. Exiting after variant recalibration!"; exit; }
	first_stage="cleanup"

fi
	
	
##	VI. CLEANUP

if [ "$first_stage" == "cleanup" ]; then

	echo "...Cleanup." >&1
	seq 1 $threads | parallel --will-cite "rm split.{}.bed"
	[ "$last_stage" == "cleanup" ] && { echo ":) Done with the requested workflow. Exiting after variant cleanup!"; exit; }

fi
	